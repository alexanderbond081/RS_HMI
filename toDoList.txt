⭡⭣⮟⮝⬇⬆⇩⇧

HMI can have infinite variety of visual elements. So this is my plan for future work, also a bugtrack list:

? какой-то жирный дебаг идет с делегатов в customdelegates.cpp
        
- Diagram Log class:
    done - 1. concept
    done - 2. basic classes description
    done - 3. basic functionality
    done - 4. paint diagram
    5. вылизываем:
        ?a.  initial position must be а multiple of secunds?
        *b. при формировании буфера надо сразу определить масштаб для каждой линии и т.п.
        *c. сетка с подписями
        *d. скроллинг и масштабирование мышой
          ! оптимизировать перелистывание
        *e. перелистывание страниц и т.п. экранными кнопками (для тачскрина? для разборчивости? для отсутствия скроллбара)
        f. курсор! - пока рисуется криво. Сделать таймер, который будет отрисовывать курсор с задержкой в 10-100мс.
        (это надо чтобы не перенагружать процессор поиском точек в массиве каждый раз при перемещении мыши на 1 пиксел)
        *g. отрисовка происходит вполне себе быстро (хоть и ожидаемо медленнее чем в паскале),
          но! формирование буфера никуда не годится. Всего пара часов точек обрабатывается аж 150мс!!!
          Это дерьмо было изза QDateTime о_О неожиданно. Теперь всё работает в 200 раз быстрее... в ДВЕСТИ 200 раз!!!
        h. в алгоритме отрисовки всё ещё присутствует некоторая кривизна, которую надо бы придумать как ...
        (на границах экрана присутствуют какие-то "дырки" при большом увеличении)
    6. доделываем главное:
        *9. реализуем функцию загрузки из файла. Тупо скопировав код из просмотрщика на паскале.
        *а. сохранение на диск - шапка, формат? формат реализованный в скрипте панели GOT1000 (с ужатием)
        *б. сохранение во время добавления новых точек? таймер?
            *- добавление новой точки будет вызывать таймер, который сохранит график через 5-10минут.
            ?- тупо сохранять раз в минуту и не дурить себе голову.
        *в. загрузка с диска во время создания объекта файла
        ?(поиск, статические поля отмечающие проверенные файлы и т.п.)
        * пока реализовал генератор имени файла по дате, т.е. имена файлов жестко заданы, никакого поиска.
        г. выгрузка лишнего?
       -> д. дозапись в файл, чтобы не пересохранять его целиком.
        e. продумать универсальный формат хранения с тем же принципом ужатия. Продумать формат хранения времени.


*setFontSize и setLableFontSize будут только в базовом классе.
*Из setFontSize будет вызываться виртуальный метод adjustSize. В adjustSize потомков будет сначала вызываться метод предка.

*-адекватное размещение элементов на форме.
  *> пройтись по всем визуальным элементам с настройками в конструкторах
  *> margin и spacing будут влиять на выбор высоты виджета, чтобы размер элементов был одинаковый при подписи сверху и сбоку.
  *> размеры viewElement теперь будут определяться по виджету(собственно this), содержащему визуальные элементы, а не по самим элементам
  *> надо как то ввести в xml настройки проектаdefaultHeight и defaultWidth, чтобы не возникало нестыковок в отображении

*-добавить к подписям wordWrap. Но ко всем подряд получается плохо, т.к. обычный текст не влазит в 2 строки при размещении по вертикали.
  *>реализовать LabelTextSize
  *>реализовать LabelWordWrap
  ?>реализовать AlignRight/Left/Center?

*-теперь интерфейс стал более "резиновым". Но почему-то на вкладках "техпроцесс" и "кусочная калибровка"
 элементы не разъезжаются до середины окна, как на вкладке "настройки ДВН" например, а поджаты до предела.
 ОТВЕТ: По умолчанию в каждый layout при создании Я ДОБАВИЛ addStretch().
        Чтобы это убрать, надо в свойствах layout прописать  ------------------
                                                             | addstretch="0" |
                                                             ------------------
 Ну а виджеты, растягиваемые до предела теперь имеют приоритет перед Stretch, ужимают их до упора так, что Stretch как бы и нет.

*-setFixedHeight для ViewElement.
  С этим у нас проблема, т.к. после установки fixedHeigth надо вызвать adjustSize потомка, чтобы подогнать
  размеры содержимого viewElement, но он в свою очередь вызывает adjustSize предка, который нахрен переделает
  размеры установленные в setFixedHeight...
  Поэтому базовый класс будет иметь метод adjustToDefaultSize, а метод потомков adjustChildrenSize.

*-реализовать теги в hmi.cpp для defaultHeight, defaultText и т.п.
*-реализовать в hmi.cpp тег для вставки spacer (раздвигатель)
?-попробовать видимый разделитель с фиксированной шириной (без expanding)
?-задание размеров каждого объекта - вроде бы работает. Сделал же универсальный метод...
  *>setFixedHeight
  >setFixedWidth - сотворить то ж самое что и с высотой.
  Задавая ширину - задаем только ширину элемента, а ширина виджета складывается из ширины элемента и подписи. Так?
  Но как быть с резиновостью подписи?
        -изучить как реализовано сейчас. Учитывается ли резиновость подписи?
        -в идеале сделать по умолчанию ширину подписи резиновой, а задание ширины - задает ширину элемента.
        -сделать задание фикс.ширины подписи и соотв.рассчеты ширины виджета. Резиновость при этом теряется.

  >рассчет ширины в методе adjustChildrenSize


*-установка размеров элемента при вертикальном расположении подписи работает не адекватно
    никак не совпадает с дефолтным размером
*-теперь разобраться с вычислением высоты если текст не стандартной высоты...
 чтобы не тратилось лишнее пространство по высоте.
 Высота виджета должна вычисляться как дефолтная высота + высота текущего текста,
 а высота элемента - как высота виджета за вычетом высоты текста...
 ...
 и тут всё поломалось когда текст в 2е строки. Б..ть.
 варианты решения:
 x- добавить некий маркер 2х-строчности, или как-то ещё определить что текст в 2е строки
   чтобы делать обратное вычисление исходного размера шрифта (текущий/0.8)
 x- исходный размер текста хранить отдельно, а в caption загонять рассчитанный.
   все размеры вычислять из отдельно сохраненного.
 ?-сделать чтобы многострочные подписи давали бОльший отступ, виджет при этом был больше...  как потом в один ряд такое ставить?
 *- вернуться к мысли об установке высоты элемента а не виджета целиком? и добавить отдельно высоту подписи? - сделал
 *- добавить кроме высоты виджета отдельно ещё и высоту элемента? - да. теперь высота виджета вычисляется из высоты подписи и высоты элемента.
 *- сделал высоту подписи задаваемой. По умолчанию высота по прежнему определяется дефолтным текстом с учетом переноса.

 ? - addStretch() добавляем в layout по умолчанию, чтобы виджеты не расползались по окну.
     это вполне удобно и замечательно, пока главное окно не начинает свои размеры по умолчанию подгонять,
     резервируя место под этот невидимый объект. Получаются "дырки" в компоновке виджетов. Выглядит ужасно.
     Как этого избежать не понятно. addStretch имеет минимальный размер = 0, зачем окно выделяет под него
     столь изрядное пространство, непонятно. Видимо придется ждать qt6+ может там всё пересломают и перепочинят.

* - проверить все alarm и log файлы на предмет выхода за размеры массива, которые
      могут возникнуть изза того что регистров больше чем текстовых меток и пояснений:

-security...
    *1. создать класс, наследуемый от viewelement(для синхронизации уровня доступа с регистром контроллера)
    *2. Заложить в него коллекцию объектов, имеющих по 2 сигнала, для каждого уровня доступа.
    *3. При изменении уровня доступа, будет выбираться соответствующий объект из коллекции(равный или меньше)
    и будет инициироваться 2 сигнала: один для разрешения (с параметром true) и один для запрета (с параметром false).
    Все подключенные к этим сигналам виджеты получат эти сигналы на соответствующие слоты SetEnabled или SetVisible.
    ?4. Реализовать этот механизм для всех визуальных объектов. - кажется это задается методом xmlCommonAttributes
        т.е. универсально для всех элементов? где эта функция вызывается во всяком случае...

*-сохранение и загрузка из файла набора регистров.
    1. Загрузку из файла организовать достаточно просто. Для этого всго-лишь надо прочитать из файла значения регистров
    и вызвать DataCollection::submitRegisterValues(). Даже если эти регистры в списке остутствовали, они автоматически добавятся и их значения отошлются контроллеру.
    2. С сохранением значений регистров в файл есть одна сложность - с большой долей вероятности они вообще будут отсутствовать в списке DataCollection,
    а если и будут, то вполне вероятно их значения будут не актуальны на данный момент. Значит необходимо продумать, механизм однократных запросов чтения
    контроллеру и синхронизации получения ответа от контроллера и сохранения информации на диск.

    ответ
    1. создать класс задачей которого будет сохранять/загружать список регистров.
    Слот для загрузки из файла. с ним всё понятно.
        а. ожиданием указание файла.
        б. читаем файл.
        в. отсылаем список регистров с данными контроллеру.
        г. ожидать завершения отправки не надо.
    Слот для сохранения файла:
        а. отсылаем на однократную загрузку список регистров.
        б. ожидаем указание файла.
        в. ожидаем опустение спика на однократную загрузку.
        г. сохраняем данные на диск.

*-теперь надо как-то сделать инициализаторы сигналов на HMI
    это могут быть:
        -пункты в меню
            x> класс Hmi читает xml с настройками, доходит до пункта DataSaveLoad??? создаёт объект класса Datasaveload
            и вызывает метод? посылает сигнал в mainwindow о желании создать пару пунктов меню и соединить их сигналами с
            объектом класса Datasaveload... но если можно, то лучше сделать иначе:
            *> --//--
            и создаёт пункт меню с названием указанным в xml и 2 подпункта save и load. И отдаёт этот указатель на этот
            пункт меню в mainwindow. Таким образом при и уничтожении окна и при уничтожении hmi рекурсивно удаляться
            и эти пункты меню. На всякий случай в hmi стоит хранить их в виде QPointer<action>
            - как хранить объекты меню? коллекция QList<QPointer<QMenu>>?
        -кнопки на панели


...-просмотреть весь код на предмет использования "родительской" системы уничтожения где возможно, а так же на предмет возможных багов связанных с непредвиденным уничтожением

*-почитать(подробно изучить) про "родительскую" систему уничтожения объектов в Qt.
x-возможно мне не стоит заморачиваться на этой хитрой системе, а свои собственные объекты удалять в деструкторе.
x*-либо сделать hmi наследником QWidget либо сделать обратную связь для корректной очистки объекта при удалении hmiWidget.
*-hmiWidget где-либо вообще участвует ПОСЛЕ размещения на него hmi?..  нет. Только если приспичит повторно вызвать loadHMI
*-PLCRegisterValidator унаследовать от QObject чтобы использовать QPointer

*-цикл обмен данными реализован через вызов sendNext - readData
*-теперь надо сформулировать таймауты и реализовать циклическую отправку данных. После подключения к порту конечно.
*-переработать по человечески PlcControllerRs485 - чтобы подключение к портам и т.п. делалось именно в нём.
    FatekCommrs только использует поле родителя port для отправки и приёма данных.
*-перенести остатки констант в статические члены класса.
*-вынести в отдельный класс создание hmi на основе xml файла
*-если редактируется значение одной из вьюшек, как обновлять остальные вьюшки с тем же регистром?
    будет оно обновляться после удачной передачи контроллеру
*-обновление во время редактирования... будет же мешать процессу редактирования или нет?
x-вместо того чтобы создавать отдельную коллекцию QList<ViewTabCollection*> xmlTabCollectionList
 подумать как этот механизм реализовать в рамках ViewTabCollection.
*-xmlMakeTable - защита от неверного кол-ва столбцов.
*-при изменении пустых/ошибочных регистров всё равно создаётся список на отправку данных

*!-придумать значит надо следующее поведение:
  *1.порт должен быть в какой-то момент определён и подключён
  этот пункт оставляю на попозже. Сейчас время заняться чуть-чуть иными вопросами.

  *2.после этого датаколлектор должен следить чтобы он оставался подключённым
  вопрос в том как работает этот qSerialPort, переподключает ли он сам в случае
  пропадания связи
  - вот эти вопросы надо бы решить сразу, но немогу ничего на данный момент придумать.
  - поэтому оставляю на потом...

*-нет защиты от переполнения буферов чтения и записи.

*-некоторые регистры при обновлении ячеек таблиц почему-то повторяются.
*!!! В одной таблице могут дублироваться регистры. Поэтому таблица с одним и тем же регистром несколько раз
    может повторяться в actualRegViewMap. И actualRegViewMap.values(reg) даёт повторы таблицы для повторяющихся
    в ней регистров.
*!  Решение: при формировании actualRegViewMap, а точнее того из чего она формируется, предотвращать повторы при
    добавлении туда таблицы.
*-вспосмнить работу с контроллером. Для обеспечения минимального управления установкой, требуется написать программу
    для контроллера с опросом и калибровками аналоговых входов и некоторыми защитами-блокировками-автоматикой
    воизбежание.
*окно настроек порта.
*файл настроек порта.

! - идея оповещения о неполадках, подсмотренная у китайцев:
    любая ошибка поднимает окно. В окне список оповещений. Новые оповещения добавляются в это же окно.
    Оповещения будут висеть, пока окно не будет закрыто. Закрывается окно нажатием кнопки подтверждения.
    Если при открытом окне неполадка пропала, то в окне оповещения она все равно остается. Если оповещение
    в окне уже есть, то оно не дублируется.

*- придумать как сделать более очевидным наличие/отсутствие соединения с контроллером.
    как вариант, вешать посередине экрана надпись "no connection" или "connecting..." или "нет связи с контроллером"...
*- как в QT повесить виджет поверх других? или проще отдельным окном?
   Вешаем отдельный виджет с флагами "setWindowFlags(Qt::WindowStaysOnTopHint|Qt::X11BypassWindowManagerHint|Qt::Popup)"

*- выбор в меню пункта "окно связи с контроллером" должно поднимать окно и делать его активным.
    Сейчас видимо вызывается метод show(), но если окно уже создано и уже видимо, то видимо этот метод ничего не делает.

*- формат времени для таблиц для TimeEditDelegate и для VaribleDelegate фиксирован setDisplayFormat("hh:mm:ss");
  Придумать как этот формат кастомизировать... чтобы например указывать "time:hh:mm:ss" или "time:hh:mm"...
  Или просто добавить форматы timeHM, timeHMS, timeH? (это проще но мне не нравится)

*- expand в аргументах конструктора и в полях класса - это лишнее. То, будет ли виджет расширяться на всё пространство
  или будет, например, стандартного размера (adjustToDefaultSize), должно определяться в конструкторе потомка.
  Лучше сделать protected метод для переключения этих решимов в реальном времени? По сути надо всего-лишь
  вызвать setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding)...
  Можно ли сделать универсальный метод, который будет учитывать viewelement_height/width и делать соответственно
  расширение отдельно по высоте и ширине? Или всё это контролировать в потомках в adjustChildrenSize?

***- систему задания размера элементов в очередной раз к чертям переделал... сча не буду описывать весь список.

!- сделать руководство по заполнению XML файла HMI, чтобы и самому не путаться и в папку с проектом вложить.

?- что такое icons.qrc

*- как сделать поддержку нескольких языков? Хотябы на уровне основных менюшек, то что в HMI.xml уже не так важно.

*- оформить проект всоответствии с требованиями lGPL...

*- новый формат ion.v10 - сделал
  определение формата и выбор метода загрузки - сделал

*- При изменении количества линий в диаграмме, загрузка предыдущих графиков и дополнение их новыми данными
  будет не корректной!
    как это избежать?
    1. Если в диаграмме уменьшилось кол-во строк, то мы не обязаны отображать все строки,
        но обязаны коректно заполнять не отображаемые строки нулями при дополнении актуальной диаграммы.
    2. Если в диаграмме увеличилось кол-во строк, то мы должны учесть это при загрузке файла, чтобы дополнение
        диаграммы новыми строками выполнялось корректно.

*- передача в файл подписей и прочей метаинфы (начал делать - не доделал)
?- отображение актуальных подписей к диаграме... а так же цвета, масштаба и т.п.  - надо оно или нет?
    Вдруг приспичит поменять, а оно на не поменяется на старых графиках? А вдруг наоборот чтото новое появится,
    например другой тип измерителя давления, надо будет менять отображение, а оно возьмет и старые графики перекаверкает?
    Думаю это надо в просмотрщике делать. А в программе надо отображать то что в настройках hmi.xml
*- как выделяется память под график и что делается если эта память закончилась?
    Есть такой TOTAL_SIZE и например если изменить период сохранения точек, то этот TOTAL_SIZE уменьшится
    и старые графики начнет обрезать на половине. Это тупо.
    Сделано это было для того, чтобы контролировать заполнение динамического массива, который был выбран в качестве хранилища информации
    т.к. скорость доступа к данным в массиве выше (и в нашем случае удобнее), чем в "фирменных" контейнерах.
    Поэтому контроль расхода памяти вот такой.
    Что с этим можно сделать?
    Как и в случае с кол-вом линий:
        для файлов из архива резервировать место следует соответственно настройкам в шапке файлов,
        а в случае актуального файла, следует выбрать наибольший размер TOTAL_SIZE/

    ... на самом деле мой формат предполагает, что может быть вообще любой интервал и длительность записи... но в данном проекте четко - 1 файл - 1 сутки
    так что вот прямо сейчас я ничего выдумывать не буду.
    Единственное что можно сделать - это оптимизировать использование памяти. Создать функцию, обрезающую TOTAL_SIZE до размеров POINTS_COUNT.
    После загрузки файла вызывать эту функцию.

    Как очищать файлы, которые уже не будут дополняться и как удалять не актуальные файлы из памяти - вопрос открытый.
*- TOTAL_SIZE надо СРАЗУ выставлять актуальным для загружаемого файла (чтобы меньше операций с памятью)

*- при изменении interval для актуального файла что надо делать? При увеличении вродебы понятно - ничего не делать, дописывать файл как есть, там сами интервалы проставятся как надо.
    А вот при уменьшении? что делать? протестим сча какие глюки могут вылезти...
    Глюки вроде не вылезли, график продолжается как надо, а вот при сохранении промежуточные точки теряются.
    Значит при уменьшении интервала, надо сначала файл загрузить, а потом взять и прописать в файле новый интервал. Вот. После пересохранения мы будем иметь новый интервал.

- заполнение notes. Туда надо бы помещать имя файла загружаемой таблицы. Как это можно сделать?
    Пока вижу только один путь - создать новую сущность в XML файле - глобалную переменную (<String default="какой-нить текст" />   или <String initial="какой-нить текст" />)
    Использовать эту глобальную переменную как источник для notes на графике.
    А чтобы в этой переменной значения так или иначе появлялись - надо реализовать механизм запихивания куда-то данных в некоторых объектах.

- т.к. у нас начинают проглядывать элементы программирования в нашем XML, надо бы эту систему упорядочить и вылизать.
    Пока это реализовано только в таблицах в виде списков строк, типов и флагов. Из которых строки и флаги объявляются в XML одинаково, но в таблице используются поразному.
    Точнее не столько поразному используются, сколько совсем не очевидно, что за цифра ставится следом за "typelist:0" или "flaglist:0" и т.п.
    Чтобы это стало очевиднее следует:
        1. раскрыть что за данные имеются в виду, например "flaglist:TextList:0"
        2. добавить возможность указывать не номер, а идентификатор, например
            <TextList name="numbers" text="1,2,3,4,5,65" />
            <Table ... types="... flaglist:TextList:numbers" ... />
        3. В целом, если нет контроля за правильностью написания в TipeList, то можно и не выделять его в отдельный тип.
        4. В целом, если не подходить слишком жестко ко всей этой теме, с контролем типов, констант и прочей бадяге,
            то можно оставить один тип - TextList или StringList и делать с этим полные чудеса,
            например использовать его в качестве аргумента для целого списка строк:
                <TextList name=labels text="1,2,3,4,5,asasd,vxcv" />
                <Table ... labels="TextList:labels" />
        5. Сделать, чтобы любой аргумент в xml можно было заменить на эти самые строки.
            Тогда, воизбежание путаницы и длинной записи TextList (ну или StringList или хз чего еще) ставить просто символ "#"
                <TextList name=labels text="1,2,3,4,5,asasd,vxcv" />
                <TextList name=files text="../log/log.log, ../options.txt" />
                <Table ... labels="#labels" />
                < ... list="#0" ... />
                < ... caption="#labels:5" ... />
                < ... filename="#0:1" ... />
                < ... register="... гыгы нет ну это уже перебор. Там будет сложно, т.к. регистры у нас жестко(через hash) привязаны к объектам.

- откуда доставать description? Подпись xml'я + подпись diagram'мы. Осталось понять откуда их выкавырить.
    Думаю надо поступить хитро - в самом классе Diagram в конструктор добавить аргумент description. А вот что туда записывать, будет определяться в hmi.cpp.
    Получится что из hmi.cpp можно засунуть в descrition что захочешь, т.к. там проще отковырять как отдельное название из xml, так и синтезировать из подписей.

!- в некоторые конструкторы передается слишком много параметров. Например в таблицы или графики. Там реально надо много параметров.
    можно конечно выделить 100% необходимые и те, которые можно заменить на что-то типовое. Например дескрипшон, подписи к линиям, масштаб, разрядность, цвета и фон.
    Но если речь о каком-то смысленном отображении, то пожертвовать можно по сути только дескрипшоном, цветами и фоном. Итого 11-3=8  всё равно много.
    Ну если оставить совсем необходимое для создания объекта с коректным логированием, но абы-каким отображением, то можно выкинуть еще подписи, масштаб, разрядность.
    Итого 8-3=5  это уже лучше.
    А теперь необходимо придумать как заменить всё это параметрами по умолчанию.
    И сделать дополнительные методы для передачи этих параметром в объект, потому что без них всё равно не возможно работать.

*- Надо реализовать выключение системы по состоянию регистра.
    Выключение проще всего сделать через выполнение системной команды shutdown. Забавно, что и в linux и в windows(от XP до 10-ки) одинаковая, чуть-чуть отличаются ключи.
    QProcess::startDetached("shutdown -P 0"); // linux
    QProcess::startDetached("shutdown /p /f"); // windows
    Для линукса рекомендуют перед выключением вызвать команду sync() из библиотеки unistd.h, чтобы сохранить системный кэш и ничего не случайно не порушить.
    Еще в линуксе нюанс, не во всех сборках пользователь по умолчанию имеет права на shutdown (если не ubuntu, то как-то возможно придется эти права раздать).

    Главный вопрос - где разместить выключение питания? Это точно не элементы отображения. Это точно должно быть где-то повыше. Это точно должно подключаться к обмену данными.
    Это точно должно создаваться в hmi.cpp, примерно как и раздача прав? Это точно должно быть в единственном экземпляре?
    Получается так:
        *- создаем отдельный класс наследник ViewElement
        *- когда указанный регистр приобретает заданное значение, включается таймер
        *- при срабатывании таймера происходит выключение
        *- если заданное значение регистра "сбрасывается", то таймер тоже сбрасывается
        - надо так же добавить опцию: пока таймер включен, на экране висит окошко (on top of the screen) с заданным сообщением (и обратным отсчетом?).
        Чтобы всё это задавать в HMI.XML надо добавить тег "Poweroff" со свойствами "register", "value", "delay" и "msg"/"message".

! - Window size defining is not a trivial thing, when you have variety of scrolling widgets inside. It works inacurate. So my decision is:
  - Have to add window_height and window_width options to xml parser. Also it would not bad to add maximize_window and fullscreen options.

  - окошко с сообщением о пропадании связи надо сделать чтобы появлялось не сразу! а после 3-10 попыток перееподключения.
После появления связи, убрать окошко через 10-30 минут после появления связи. Может просто сделать текстовый системный лог вместо окошек и прочего?
- нет визуализации чисел в шеснадцатиричном, двоичном и т.п. виде
- надо добавить лог открытия и сохранения рецептов, чтобы можно было понять, например, какому рецепту соответствует диаграмма.

done - проверить все файлы в проекте на предмет наличия плашки LGPL
done - проверить все файлы в директории и убрать не используемые
- переделать комментарии на английский

